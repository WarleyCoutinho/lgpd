"use strict";
exports.__esModule = true;
var nativeMap = Array.prototype.map;
var nativeIsArray = Array.isArray;
var toString = Object.prototype.toString;
function __isNull(obj) {
    return typeof obj === 'undefined' || obj === null;
}
exports.__isNull = __isNull;
;
function __isString(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
}
exports.__isString = __isString;
;
function __isArray(obj) {
    return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]';
}
exports.__isArray = __isArray;
;
function __isObject(obj) {
    return obj && toString.call(obj) === '[object Object]';
}
exports.__isObject = __isObject;
;
function __defaults(object, defs) {
    var key;
    object = object || {};
    defs = defs || {};
    // Iterate over object non-prototype properties:
    for (key in defs) {
        // eslint-disable-next-line no-prototype-builtins
        if (defs.hasOwnProperty(key)) {
            // Replace values with defaults only if undefined (allow empty/zero values):
            if (object[key] == null)
                object[key] = defs[key];
        }
    }
    return object;
}
exports.__defaults = __defaults;
;
function __map(obj, iterator, context) {
    if (!obj)
        return [];
    // Use native .map method if it exists:
    if (nativeMap && obj.map === nativeMap)
        return obj.map(iterator, context);
    var results = [];
    var i = 0;
    var j = 0;
    // Fallback for native .map:
    for (i = 0, j = obj.length; i < j; i++) {
        results[i] = iterator.call(context, obj[i], i, obj);
    }
    return results;
}
exports.__map = __map;
